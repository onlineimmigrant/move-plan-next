# Model-Specific Settings Implementation ‚úÖ

## Problem Solved

### ‚ùå Previous Issue
- `ai_user_settings` table had only ONE `default_settings` column per user
- When switching between AI models, the same settings were applied to ALL models
- Settings extracted for Model A would incorrectly be used for Model B
- No way to maintain different configurations per model

### ‚úÖ Solution
- Created new `ai_model_settings` table to store settings **per user per model**
- Each user can have different settings for each AI model they use
- Settings automatically load when switching models
- Settings auto-save per model

## Database Changes

### New Table: `ai_model_settings`

```sql
CREATE TABLE public.ai_model_settings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL,
  model_id bigint NOT NULL,
  model_type text NOT NULL CHECK (model_type IN ('default', 'user')),
  settings jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  
  UNIQUE (user_id, model_id, model_type),
  FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE
);
```

**Indexes:**
- `idx_ai_model_settings_user_id` on `(user_id)`
- `idx_ai_model_settings_model` on `(model_id, model_type)`

**Auto-update Trigger:**
- `updated_at` automatically updates on every modification

### Modified Table: `ai_user_settings`

**Removed:**
- `default_settings` column (moved to `ai_model_settings`)

**Keeps:**
- `default_model_id` - Currently selected default model
- `user_model_id` - Currently selected user model
- `selected_model_type` - Which type is active ('default' or 'user')
- `files` - Global files (not model-specific)

## Migration File

**Location:** `/database/migrations/fix_model_specific_settings.sql`

**What it does:**
1. Creates `ai_model_settings` table
2. Adds indexes for performance
3. Creates auto-update trigger
4. Migrates existing `default_settings` from `ai_user_settings` to `ai_model_settings`
5. Removes `default_settings` column from `ai_user_settings`
6. Adds helpful comments

**Run in Supabase SQL Editor:**
```sql
-- Execute the migration
/database/migrations/fix_model_specific_settings.sql
```

## Code Changes

### 1. API Route: `/api/chat/settings/route.ts`

**Before:**
```typescript
// Fetched from ai_user_settings.default_settings
// Same settings for all models
```

**After:**
```typescript
// Requires: modelId, modelType in request body
POST /api/chat/settings
{
  "action": "add" | "update" | "delete",
  "settingKey": "key_name",
  "settingValue": "value",
  "modelId": 123,
  "modelType": "default" | "user"
}

// Response:
{
  "settings": { ...model-specific settings... }
}
```

**Key Changes:**
- Validates `modelId` and `modelType` are provided
- Queries `ai_model_settings` table instead of `ai_user_settings`
- Creates new record if none exists for this user+model combination
- Updates existing record if it exists

### 2. ChatWidget Component

**New Function: `loadModelSettings`**
```typescript
const loadModelSettings = async (modelId: number, modelType: 'default' | 'user') => {
  // Fetches settings from ai_model_settings for specific model
  // Updates defaultSettings and selectedSettings states
  // Handles case where no settings exist yet
};
```

**New useEffect:**
```typescript
// Automatically load settings when selected model changes
useEffect(() => {
  if (selectedModel && isAuthenticated && userId) {
    loadModelSettings(selectedModel.id, selectedModel.type);
  }
}, [selectedModel?.id, selectedModel?.type, isAuthenticated, userId]);
```

**Modified Initialization:**
- Removed fetching `default_settings` from `ai_user_settings`
- Settings now load per-model via `loadModelSettings`

### 3. SettingsModal Component

**New Prop:**
```typescript
interface SettingsModalProps {
  // ... existing props ...
  selectedModel: Model | null;  // NEW
}
```

**Updated API Calls:**
All CRUD operations now include model information:

```typescript
// Add Setting
body: JSON.stringify({
  action: 'add',
  settingKey: key,
  settingValue: parsedValue,
  modelId: selectedModel.id,      // NEW
  modelType: selectedModel.type,   // NEW
})

// Update Setting
body: JSON.stringify({
  action: 'update',
  settingKey: originalKey,
  settingValue: parsedValue,
  modelId: selectedModel.id,      // NEW
  modelType: selectedModel.type,   // NEW
})

// Delete Setting
body: JSON.stringify({
  action: 'delete',
  settingKey: key,
  modelId: selectedModel.id,      // NEW
  modelType: selectedModel.type,   // NEW
})
```

## User Experience

### How It Works Now

1. **User selects Model A**
   - Settings for Model A automatically load
   - User sees Model A's specific settings
   - User can add/edit settings
   - Settings save to Model A's record

2. **User switches to Model B**
   - Settings for Model B automatically load
   - User sees Model B's specific settings (different from Model A)
   - Model A's settings remain unchanged

3. **Auto-Extraction**
   - When extraction occurs, settings update for current model only
   - Other models' settings remain unchanged

### Example Scenario

```
User has 3 models:
‚îú‚îÄ GPT-4 (default model #1)
‚îÇ  ‚îî‚îÄ Settings: { "tone": "professional", "format": "markdown" }
‚îú‚îÄ Claude (default model #2)
‚îÇ  ‚îî‚îÄ Settings: { "tone": "casual", "max_tokens": "2000" }
‚îî‚îÄ Custom Model (user model #5)
   ‚îî‚îÄ Settings: { "temperature": "0.7", "context": "tech" }

When user switches:
- Select GPT-4 ‚Üí Loads professional/markdown settings
- Select Claude ‚Üí Loads casual/2000 tokens settings  
- Select Custom ‚Üí Loads 0.7 temp/tech context settings
```

## Database Structure

### Before (Wrong)
```
ai_user_settings
‚îú‚îÄ user_id: abc-123
‚îú‚îÄ default_model_id: 1 (GPT-4)
‚îî‚îÄ default_settings: {"tone": "professional"}
   ‚îî‚îÄ ‚ùå Problem: Same settings used for ALL models!
```

### After (Correct)
```
ai_user_settings
‚îú‚îÄ user_id: abc-123
‚îú‚îÄ default_model_id: 1 (currently selected)
‚îî‚îÄ selected_model_type: 'default'

ai_model_settings
‚îú‚îÄ Record 1: user=abc-123, model=1, type=default
‚îÇ  ‚îî‚îÄ settings: {"tone": "professional", "format": "markdown"}
‚îú‚îÄ Record 2: user=abc-123, model=2, type=default
‚îÇ  ‚îî‚îÄ settings: {"tone": "casual", "max_tokens": "2000"}
‚îî‚îÄ Record 3: user=abc-123, model=5, type=user
   ‚îî‚îÄ settings: {"temperature": "0.7", "context": "tech"}
```

## Query Examples

### Get Settings for Specific Model
```sql
SELECT settings
FROM ai_model_settings
WHERE user_id = 'abc-123'
  AND model_id = 1
  AND model_type = 'default';
```

### Get All Settings for a User
```sql
SELECT model_id, model_type, settings
FROM ai_model_settings
WHERE user_id = 'abc-123'
ORDER BY created_at DESC;
```

### Update Settings for Specific Model
```sql
UPDATE ai_model_settings
SET settings = '{"tone": "professional", "format": "json"}',
    updated_at = now()
WHERE user_id = 'abc-123'
  AND model_id = 1
  AND model_type = 'default';
```

### Create Settings for New Model
```sql
INSERT INTO ai_model_settings (user_id, model_id, model_type, settings)
VALUES ('abc-123', 3, 'default', '{"temperature": "0.5"}')
ON CONFLICT (user_id, model_id, model_type) DO NOTHING;
```

## Testing Checklist

### Before Migration
- [ ] Backup `ai_user_settings` table
- [ ] Note existing `default_settings` for comparison
- [ ] Backup database

### After Migration
- [ ] Verify `ai_model_settings` table exists
- [ ] Check existing settings migrated correctly
- [ ] Confirm `default_settings` column removed from `ai_user_settings`
- [ ] Test creating settings for new model
- [ ] Test updating existing settings
- [ ] Test deleting settings
- [ ] Test switching between models (settings load correctly)

### Functional Testing
- [ ] Select Model A, add setting ‚Üí saves to Model A
- [ ] Switch to Model B ‚Üí different/empty settings shown
- [ ] Add setting to Model B ‚Üí saves to Model B only
- [ ] Switch back to Model A ‚Üí original settings still there
- [ ] Run extraction on Model A ‚Üí updates Model A settings only
- [ ] Switch to Model B ‚Üí extraction didn't affect Model B settings
- [ ] Delete setting from Model A ‚Üí only Model A affected

## Benefits

### For Users
‚úÖ Different settings per model (tone, format, context, etc.)
‚úÖ Settings automatically load when switching models
‚úÖ No confusion from wrong settings applied to wrong model
‚úÖ Extraction results apply only to current model

### For System
‚úÖ Clean data separation
‚úÖ Scalable (unlimited models per user)
‚úÖ Efficient queries with proper indexes
‚úÖ Cascade deletes (remove user ‚Üí removes all their model settings)

### For Developers
‚úÖ Clear table structure
‚úÖ Type-safe model identification (model_id + model_type)
‚úÖ Automatic timestamp management
‚úÖ Simple migration from old structure

## Rollback Plan

If issues occur, rollback by:

1. **Re-add `default_settings` column:**
```sql
ALTER TABLE ai_user_settings
ADD COLUMN default_settings jsonb DEFAULT '{}'::jsonb;
```

2. **Copy most recent settings back:**
```sql
UPDATE ai_user_settings us
SET default_settings = (
  SELECT ams.settings
  FROM ai_model_settings ams
  WHERE ams.user_id = us.user_id
    AND ((us.selected_model_type = 'default' AND ams.model_id = us.default_model_id)
      OR (us.selected_model_type = 'user' AND ams.model_id = us.user_model_id))
  LIMIT 1
);
```

3. **Revert code changes** (Git revert)

## Summary

This implementation fixes a critical issue where all AI models shared the same settings per user. Now:

- Each user can have **unique settings for each AI model**
- Settings **automatically load** when switching models
- **Extraction results** apply only to the current model
- **Clean separation** of concerns in database
- **Backwards compatible** migration of existing data

The system is now properly architected for multi-model support with per-model configurations! üéâ
