"use client";
import { useState, useEffect, useRef, useCallback } from "react";
import { supabase } from "@/lib/supabaseClient";
import { generateSlug } from "./DynamicTableComponents/utils";
import { Item, FilterCriteria, SortCriteria, ForeignKeyOption, EditingCell } from "./DynamicTableComponents/types";
import { AddNewModal, DeleteConfirmationModal, FilterMenu, SortMenu, ColumnsMenu, TableNavbar, SelectedRowsNavbar, TableHeader, TableBody, ExpandRowModal, PageSorting, ImportCSVModal, ExportCSVModal, AddColumnModal, EditColumnModal, DeleteColumnModal, SchemaModal } from "./DynamicTableComponents/index";

export default function DynamicTable({ tableName, apiEndpoint }: { tableName: string; apiEndpoint: string }) {
  const [foreignKeys, setForeignKeys] = useState<{ [key: string]: { relatedTable: string; relatedColumn: string } }>({});
  const [items, setItems] = useState<Item[]>([]);
  const [originalItems, setOriginalItems] = useState<Item[]>([]);
  const [selectedRows, setSelectedRows] = useState<string[]>([]);
  const [editingCell, setEditingCell] = useState<EditingCell | null>(null);
  const [editValue, setEditValue] = useState<string>("");
  const [fields, setFields] = useState<string[]>([]);
  const [hiddenFields, setHiddenFields] = useState<string[]>([]);
  const [columnTypes, setColumnTypes] = useState<{ [key: string]: string }>({});
  const [columnDefaults, setColumnDefaults] = useState<{ [key: string]: any }>({});
  const [isServerManaged, setIsServerManaged] = useState<{ [key: string]: boolean }>({}); // Replaces isAutoGenerated
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isDeleteModalOpen, setIsDeleteModalOpen] = useState(false);
  const [isImportModalOpen, setIsImportModalOpen] = useState(false);
  const [isExportModalOpen, setIsExportModalOpen] = useState(false);
  const [isAddColumnModalOpen, setIsAddColumnModalOpen] = useState(false);
  const [isEditColumnModalOpen, setIsEditColumnModalOpen] = useState(false);
  const [isDeleteColumnModalOpen, setIsDeleteColumnModalOpen] = useState(false);
  const [isColumnsMenuOpen, setIsColumnsMenuOpen] = useState(false);
  const [newItem, setNewItem] = useState<{ [key: string]: string }>({});
  const [isFilterOpen, setIsFilterOpen] = useState(false);
  const [isSortOpen, setIsSortOpen] = useState(false);
  const [filterCriteria, setFilterCriteria] = useState<FilterCriteria | null>(null);
  const [sortCriteria, setSortCriteria] = useState<SortCriteria | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [modalPosition, setModalPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [draggedColumn, setDraggedColumn] = useState<string | null>(null);
  const [existingSlugs, setExistingSlugs] = useState<string[]>([]);
  const [foreignKeyOptions, setForeignKeyOptions] = useState<{ [key: string]: ForeignKeyOption[] }>({});
  const [isExpandModalOpen, setIsExpandModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState<Item | null>(null);
  const [itemsPerPage, setItemsPerPage] = useState<number | "all">(20);
  const [currentPage, setCurrentPage] = useState(1);
  const [isForeignKeyModalOpen, setIsForeignKeyModalOpen] = useState(false);
  const [selectedForeignKeyItem, setSelectedForeignKeyItem] = useState<Item | null>(null);
  const [selectedColumn, setSelectedColumn] = useState<string | null>(null);
  const [displayedItems, setDisplayedItems] = useState<Item[]>([]);
  const [columnWidths, setColumnWidths] = useState<{ [key: string]: number }>({ checkbox: 40 });
  const [isSchemaModalOpen, setIsSchemaModalOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  const inputRefs = useRef<(HTMLInputElement | null)[][]>([]);
  const modalRef = useRef<HTMLDivElement>(null);
  const unchangeableFields = ["id", "created_at", "updated_at"];
  const buttonClass = "px-3 py-1 rounded-md text-xs transition-colors flex items-center gap-1";
  const grayButtonClass = `${buttonClass} bg-gray-200 text-gray-700 hover:bg-gray-300`;
  const primaryButtonClass = `${buttonClass} bg-gray-600 text-white hover:bg-gray-700`;

  useEffect(() => {
    setColumnWidths((prev) => {
      const newWidths: { [key: string]: number } = { ...prev, checkbox: 40 };
      fields.forEach((field) => {
        if (!(field in newWidths)) {
          newWidths[field] = 150;
        }
      });
      return newWidths;
    });
  }, [fields]);

  useEffect(() => {
    const saved = localStorage.getItem(`${tableName}_itemsPerPage`);
    if (saved) setItemsPerPage(saved === "all" ? "all" : parseInt(saved, 10));
  }, [tableName]);

  const fetchData = async () => {
    try {
      setIsLoading(true);
      console.log("Fetching from apiEndpoint:", apiEndpoint);
      const res = await fetch(apiEndpoint);
      if (!res.ok) {
        const errorText = await res.text();
        console.error("Fetch error response:", errorText);
        throw new Error(`Failed to fetch ${tableName}: ${errorText}`);
      }
      const data = await res.json();
      console.log("API response:", data);
      const fetchedItems = data[tableName] || [];
      
      const schemaFields = Object.keys(data.columnTypes || {});
      console.log("Schema fields from columnTypes:", schemaFields);
  
      const savedOrder = JSON.parse(localStorage.getItem(`${tableName}_columnOrder`) || "null") || schemaFields;
      const updatedFields = savedOrder.filter((field: string) => schemaFields.includes(field));
      schemaFields.forEach((field: string) => {
        if (!updatedFields.includes(field)) updatedFields.push(field);
      });
      localStorage.setItem(`${tableName}_columnOrder`, JSON.stringify(updatedFields));
      const savedHidden = JSON.parse(localStorage.getItem(`${tableName}_hiddenFields`) || "null") || [];
      console.log("Updated fields after filtering:", updatedFields);
      console.log("Saved hidden fields:", savedHidden);
  
      setFields([...updatedFields]);
      setHiddenFields(savedHidden);
      setExistingSlugs(fetchedItems.map((item: Item) => item.slug).filter(Boolean));
      setItems(fetchedItems);
      setOriginalItems(fetchedItems);
      setColumnTypes(data.columnTypes || {});
      setColumnDefaults(data.columnDefaults || {});
      setIsServerManaged(data.isServerManaged || {});
      setForeignKeys(data.foreignKeys || {});
      setForeignKeyOptions(data.foreignKeyOptions || {});
      setError(null);
  
      console.log("State fields after setFields:", updatedFields);
  
      const savedSort = localStorage.getItem(`${tableName}_sortOrder`);
      if (savedSort) setSortCriteria(JSON.parse(savedSort));
    } catch (err: any) {
      console.error("Error loading items:", err);
      setError(err.message || "Failed to load data");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [apiEndpoint, tableName]);

  useEffect(() => {
    if (fields.length && Object.keys(columnTypes).length && Object.keys(isServerManaged).length) {
      const initialNewItem = fields.reduce((acc, field) => {
        if (!isServerManaged[field]) {
          acc[field] = columnDefaults[field]?.toString() || "";
        }
        return acc;
      }, {} as { [key: string]: string });
      console.log("Initial newItem set:", JSON.stringify(initialNewItem, null, 2));
      setNewItem(initialNewItem);
    }
  }, [fields, columnTypes, columnDefaults, isServerManaged]);

  useEffect(() => {
    const channel = supabase
      .channel(`${tableName}-changes`)
      .on("postgres_changes", { event: "*", schema: "public", table: tableName }, (payload: any) => {
        const updateItems = (current: Item[]) => {
          switch (payload.eventType) {
            case "INSERT": return current.some(item => item.id === payload.new.id) ? current : [...current, payload.new];
            case "UPDATE": return current.map(item => item.id === payload.new.id ? payload.new : item);
            case "DELETE": return current.filter(item => item.id !== payload.old.id);
            default: return current;
          }
        };
        setItems(prev => updateItems(prev));
        setOriginalItems(prev => updateItems(prev));
        if (payload.eventType === "DELETE") setSelectedRows(prev => prev.filter(id => id !== payload.old.id));
        if (payload.eventType === "INSERT" && payload.new.slug) setExistingSlugs(prev => [...prev, payload.new.slug]);
        if (payload.eventType === "DELETE" && payload.old.slug) setExistingSlugs(prev => prev.filter(slug => slug !== payload.old.slug));
      })
      .subscribe();
    return () => { supabase.removeChannel(channel); };
  }, [tableName]);

  useEffect(() => {
    let filteredItems = [...originalItems];

    if (filterCriteria) {
      filteredItems = filteredItems.filter((item) =>
        item[filterCriteria.field]?.toString().toLowerCase().includes(filterCriteria.value.toLowerCase())
      );
    }

    if (sortCriteria) {
      filteredItems.sort((a, b) => {
        const aValue = a[sortCriteria.field];
        const bValue = b[sortCriteria.field];
        const type = columnTypes[sortCriteria.field]?.toLowerCase();

        if (type === "integer" || type === "numeric" || type === "bigint") {
          const aNum = aValue !== null && aValue !== undefined ? Number(aValue) : 0;
          const bNum = bValue !== null && bValue !== undefined ? Number(bValue) : 0;
          return sortCriteria.direction === "asc" ? aNum - bNum : bNum - aNum;
        }

        const aStr = aValue?.toString().toLowerCase() || "";
        const bStr = bValue?.toString().toLowerCase() || "";
        return sortCriteria.direction === "asc" ? aStr.localeCompare(bStr) : bStr.localeCompare(aStr);
      });
    }

    if (itemsPerPage === "all") {
      setDisplayedItems(filteredItems);
    } else {
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      setDisplayedItems(filteredItems.slice(startIndex, endIndex));
    }

    if (itemsPerPage !== "all") {
      const maxPage = Math.ceil(filteredItems.length / itemsPerPage);
      if (currentPage > maxPage) setCurrentPage(maxPage || 1);
    }
  }, [filterCriteria, sortCriteria, originalItems, columnTypes, itemsPerPage, currentPage]);

  const handleDragStart = (e: React.MouseEvent<HTMLDivElement>) => {
    setIsDragging(true);
    setDragStart({ x: e.clientX - modalPosition.x, y: e.clientY - modalPosition.y });
  };

  const handleDrag = useCallback((e: MouseEvent) => {
    if (isDragging) setModalPosition({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
  }, [isDragging, dragStart]);

  useEffect(() => {
    if (isDragging) {
      window.addEventListener("mousemove", handleDrag);
      window.addEventListener("mouseup", () => setIsDragging(false));
      return () => { window.removeEventListener("mousemove", handleDrag); window.removeEventListener("mouseup", () => {}); };
    }
  }, [isDragging, handleDrag]);

  const handleColumnDrop = (e: React.DragEvent<HTMLTableHeaderCellElement>, targetField: string) => {
    e.preventDefault();
    if (draggedColumn && draggedColumn !== targetField) {
      const newFields = [...fields];
      const [draggedIndex, targetIndex] = [newFields.indexOf(draggedColumn), newFields.indexOf(targetField)];
      newFields.splice(draggedIndex, 1);
      newFields.splice(targetIndex, 0, draggedColumn);
      setFields(newFields);
      localStorage.setItem(`${tableName}_columnOrder`, JSON.stringify(newFields));
    }
    setDraggedColumn(null);
  };

  const foreignKeyTableMap: { [key: string]: string } = {
    primary_color_id: "color.name",
    secondary_color_id: "color.name",
    primary_font_id: "font.name",
    secondary_font_id: "font.name",
    font_size_base_id: "size.name",
    font_size_small_id: "size.name",
    font_size_large_id: "size.name",
    product_id: "product.product_name",
    cookie_consent_id: "cookie_consent.name",
    pack_type_id: "pack_types.name",
    item_type_id: "item_types.name",
    user_id: "profiles.username",
    pricing_plan_id: "pricingplan.measure",
    current_country: "countries.iso_alpha2",
    currency_for_plan: "currency.code",
    relocation_plan_id: "relocation_plans.id",
    homepage_id: "website_homepage.hero_name",
    brand_id: "website_brand.name",
    h1_title_color_id: "color.name",
    h1_via_gradient_color_id: "color.name",
    react_icon_id: "react_icons.icon_name",
    footer_color_id: "color.name",
    stripe_customer_id: 'stripe_customer'
  };

  const fetchForeignKeyOptions = async (field: string) => {
    const [relatedTable, displayColumn] = (foreignKeyTableMap[field] || field.replace("_id", ".name")).split(".");
    console.log(`Fetching options for field: ${field}, relatedTable: ${relatedTable}, displayColumn: ${displayColumn}`);
  
    try {
      const possibleColumns = [displayColumn || "name", "product_name", "title", "description"];
      let selectedColumn = displayColumn || "name";
      const { data: schemaData, error: schemaError } = await supabase.rpc("get_column_types", { p_table_name: relatedTable });
  
      if (schemaError) {
        console.warn(`Could not fetch schema for ${relatedTable}:`, schemaError);
      } else if (schemaData) {
        const availableColumns = schemaData.map((col: { column_name: string }) => col.column_name);
        console.log(`Available columns in ${relatedTable}:`, availableColumns);
        selectedColumn = possibleColumns.find(col => availableColumns.includes(col)) || "id";
      }
  
      const { data, error } = await supabase.from(relatedTable).select(`id, ${selectedColumn}`).order(selectedColumn, { ascending: true });
      if (error) throw new Error(error.message);
  
      setForeignKeyOptions(prev => ({
        ...prev,
        [field]: data.map((item: any) => ({
          id: item.id.toString(),
          name: item[selectedColumn] || item.id.toString(),
        })),
      }));
    } catch (err: any) {
      console.error(`Error fetching options for ${relatedTable}:`, err);
    }
  };

  const startEditing = async (id: string, field: string, value: string) => {
    setEditingCell({ id, field });
    setEditValue(value || "");
    if (field.endsWith("_id")) await fetchForeignKeyOptions(field);
  };

  const handleFormInputChange = useCallback((field: string, value: string) => {
    setNewItem(prev => {
      const updatedItem = { ...prev, [field]: value };
      if ((field === "product_name" || field === "name") && fields.includes("slug")) {
        const productNameValue = updatedItem.product_name || "";
        const nameValue = updatedItem.name || "";
        updatedItem.slug = (productNameValue.trim() || nameValue.trim()) ? generateSlug(productNameValue, nameValue, existingSlugs) : "";
      }
      console.log(`Updated newItem after input change (${field}):`, JSON.stringify(updatedItem, null, 2));
      return updatedItem;
    });
  }, [fields, existingSlugs]);

  const resetForm = () => {
    const resetItem = fields.reduce((acc, field) => {
      if (!isServerManaged[field]) {
        acc[field] = columnDefaults[field]?.toString() || "";
      }
      return acc;
    }, {} as { [key: string]: string });
    console.log("Reset newItem:", JSON.stringify(resetItem, null, 2));
    setNewItem(resetItem);
  };

  const handleSubmit = async (e: React.FormEvent, isExpand = false) => {
    e.preventDefault();
    const item = isExpand && selectedItem ? { ...newItem, id: selectedItem.id } : newItem;
    const method = isExpand ? "PUT" : "POST";

    console.log("Raw newItem before filtering:", JSON.stringify(item, null, 2));
    console.log("Available columnTypes:", JSON.stringify(columnTypes, null, 2));
    console.log("Available columnDefaults:", JSON.stringify(columnDefaults, null, 2));
    console.log("Available isServerManaged:", JSON.stringify(isServerManaged, null, 2));

    try {
      if (isExpand) {
        const changedFields = Object.keys(item).reduce(
          (acc, field) =>
            item[field] !== selectedItem![field]?.toString()
              ? { ...acc, [field]: convertValue(field, item[field]) }
              : acc,
          {}
        );

        for (const [field, value] of Object.entries(changedFields)) {
          if (field === "id") continue;
          const body = { id: item.id, field, value };
          console.log(`PUT request body for ${field}:`, JSON.stringify(body, null, 2));
          const res = await fetch(apiEndpoint, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            throw new Error(`Error updating ${tableName}: ${await res.text()}`);
          }
        }

        setItems(prev => prev.map(i => i.id === selectedItem!.id ? { ...i, ...newItem } : i));
        setOriginalItems(prev => prev.map(i => i.id === selectedItem!.id ? { ...i, ...newItem } : i));
        setIsExpandModalOpen(false);
        setSelectedItem(null);
      } else {
        const body = Object.keys(item)
          .filter(field => {
            const value = item[field];
            const type = columnTypes[field]?.toLowerCase() || "unknown";
            const hasDefault = columnDefaults[field] !== null && columnDefaults[field] !== undefined;
            const serverManaged = isServerManaged[field] || false;

            console.log(`Filtering field: ${field}, Value: "${value}", Type: ${type}, HasDefault: ${hasDefault}, ServerManaged: ${serverManaged}`);

            const isInvalid = value === "" || value === null || value === undefined;
            const shouldInclude = !serverManaged || (value !== "" && value !== null && value !== undefined);
            console.log(`Field ${field} included: ${shouldInclude}`);
            return shouldInclude;
          })
          .reduce((acc, field) => {
            const convertedValue = convertValue(field, item[field]);
            console.log(`Field: ${field}, Converted Value: ${JSON.stringify(convertedValue)}`);
            return { ...acc, [field]: convertedValue };
          }, {});

        console.log("POST payload being sent:", JSON.stringify(body, null, 2));
        const res = await fetch(apiEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        const responseText = await res.text();
        console.log("Server response:", responseText);
        if (!res.ok) {
          throw new Error(`Error creating ${tableName}: ${responseText}`);
        }

        const responseData = JSON.parse(responseText);
        const newItemFromServer = responseData[tableName];
        console.log("New item from server:", JSON.stringify(newItemFromServer, null, 2));
        setItems(prev => [...prev, newItemFromServer]);
        setOriginalItems(prev => [...prev, newItemFromServer]);
        resetForm();
        setIsModalOpen(false);
      }
    } catch (err: any) {
      console.error(`Error in handleSubmit (${isExpand ? "expand" : "add"}):`, err);
      setError(err.message || `Failed to ${isExpand ? "update" : "create"} item`);
    }
  };

  const convertValue = (field: string, value: string) => {
    const type = columnTypes[field]?.toLowerCase();

    console.log(`Converting field: ${field}, Value: "${value}", Type: ${type || "unknown"}`);

    if (value === "" || value === null || value === undefined) {
      if (["timestamp", "timestamptz", "date"].includes(type)) {
        console.log(`Converted ${field} to null (timestamp)`);
        return null;
      }
      if (["numeric", "integer", "bigint"].includes(type)) {
        console.log(`Converted ${field} to null (numeric)`);
        return null;
      }
      if (type === "boolean") {
        console.log(`Converted ${field} to null (boolean)`);
        return null;
      }
      return value;
    }

    if (["timestamp", "timestamptz"].includes(type)) {
      const date = new Date(value);
      const result = isNaN(date.getTime()) ? null : date.toISOString();
      console.log(`Converted ${field} to ${result} (timestamp)`);
      return result;
    }
    if (type === "boolean") {
      const result = value.toLowerCase() === "true" ? true : value.toLowerCase() === "false" ? false : null;
      console.log(`Converted ${field} to ${result} (boolean)`);
      return result;
    }
    if (["numeric", "integer", "bigint"].includes(type)) {
      const num = Number(value);
      const result = isNaN(num) ? null : num;
      console.log(`Converted ${field} to ${result} (numeric)`);
      return result;
    }
    console.log(`Converted ${field} to ${value} (default)`);
    return value;
  };

  const handleDeleteSelected = async () => {
    try {
      for (const id of selectedRows) {
        const res = await fetch(apiEndpoint, {
          method: "DELETE",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id }),
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(`Error deleting ${tableName}: ${text}`);
        }
      }
      setItems(prev => {
        const updatedItems = prev.filter(item => !selectedRows.includes(item.id));
        console.log("Manually updated items after DELETE:", updatedItems);
        return updatedItems;
      });
      setOriginalItems(prev => {
        const updatedItems = prev.filter(item => !selectedRows.includes(item.id));
        console.log("Manually updated originalItems after DELETE:", updatedItems);
        return updatedItems;
      });
      setSelectedRows([]);
      setIsDeleteModalOpen(false);
    } catch (err: any) {
      console.error("Error in handleDeleteSelected:", err);
      setError(err.message || "Failed to delete selected items");
    }
  };

  const saveEdit = async (id: string, field: string, originalValue: string) => {
    console.log(`Saving edit for id: ${id}, field: ${field}, originalValue: ${originalValue}, newValue: ${editValue}`);
    if (editValue !== originalValue) {
      const type = columnTypes[field]?.toLowerCase();
      let valueToUpdate: any = editValue;
      if (editValue === "" && (type === "numeric" || type === "integer" || type === "bigint" || type === "date" || type === "timestamp")) {
        valueToUpdate = null;
      } else if (type === "boolean" && typeof editValue === "string") {
        valueToUpdate = editValue.toLowerCase() === "true" ? true : editValue.toLowerCase() === "false" ? false : null;
      }

      try {
        const res = await fetch(apiEndpoint, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id, field, value: valueToUpdate }),
        });

        if (!res.ok) {
          const text = await res.text();
          console.error(`Error updating ${tableName}:`, text);
          throw new Error(`Failed to update ${tableName}: ${text}`);
        }

        const updatedData = await res.json();
        const updatedItem = updatedData[tableName];

        setItems(prev => {
          const updatedItems = prev.map(item => item.id === id ? { ...item, [field]: updatedItem[field] } : item);
          console.log("Manually updated items after PUT:", updatedItems);
          return [...updatedItems];
        });
        setOriginalItems(prev => {
          const updatedItems = prev.map(item => item.id === id ? { ...item, [field]: updatedItem[field] } : item);
          console.log("Manually updated originalItems after PUT:", updatedItems);
          return [...updatedItems];
        });
      } catch (err: any) {
        console.error("Error in saveEdit:", err);
        setError(err.message || "Failed to save edit");
        return;
      }
    }
    setEditingCell(null);
    setEditValue("");
  };

  const setToNull = async (id: string, field: string) => {
    const res = await fetch(apiEndpoint, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ id, field, value: null }),
    });
    if (!res.ok) {
      const text = await res.text();
      console.error(`Error updating ${tableName}:`, text);
      return;
    }
    setItems(prev => {
      const updatedItems = prev.map(item => item.id === id ? { ...item, [field]: null } : item);
      console.log("Manually updated items after setToNull:", updatedItems);
      return updatedItems;
    });
    setOriginalItems(prev => {
      const updatedItems = prev.map(item => item.id === id ? { ...item, [field]: null } : item);
      console.log("Manually updated originalItems after setToNull:", updatedItems);
      return updatedItems;
    });
    setEditingCell(null);
    setEditValue("");
  };

  const applyFilter = (field: string, value: string) => {
    setFilterCriteria({ field, value });
    setIsFilterOpen(false);
  };

  const clearFilter = () => {
    setFilterCriteria(null);
    setIsFilterOpen(false);
  };

  const applySort = (field: string, direction: "asc" | "desc") => {
    const newSortCriteria = { field, direction };
    setSortCriteria(newSortCriteria);
    localStorage.setItem(`${tableName}_sortOrder`, JSON.stringify(newSortCriteria));
    setOriginalItems([...items]);
    setIsSortOpen(false);
  };

  const clearSort = () => {
    setSortCriteria(null);
    localStorage.removeItem(`${tableName}_sortOrder`);
    setIsSortOpen(false);
  };

  const handleColumnSuccess = () => fetchData();

  const pageSortingComponent = (
    <PageSorting
      tableName={tableName}
      itemsPerPage={itemsPerPage}
      setItemsPerPage={setItemsPerPage}
      totalItems={items.length}
      currentPage={currentPage}
      setCurrentPage={setCurrentPage}
    />
  );

  if (error) return <div className="p-6 bg-gray-50 min-h-screen text-red-600 text-center">{error}</div>;

  return (
    <div className="p-4 bg-gray-50 min-h-screen">
      <AddNewModal greenButtonClass={""} {...{ isModalOpen, setIsModalOpen, modalRef, modalPosition, handleDragStart, handleSubmit, fields, unchangeableFields, hiddenFields, newItem, handleFormInputChange, primaryButtonClass, grayButtonClass }} />
      <DeleteConfirmationModal redButtonClass={""} {...{ isDeleteModalOpen, setIsDeleteModalOpen, selectedRows, handleDeleteSelected, primaryButtonClass, grayButtonClass }} />
      <ExpandRowModal {...{ isExpandModalOpen, setIsExpandModalOpen, selectedItem, fields, unchangeableFields, hiddenFields, newItem, handleFormInputChange, handleSubmit: (e) => handleSubmit(e, true), primaryButtonClass, grayButtonClass }} />
      <ImportCSVModal {...{ isOpen: isImportModalOpen, setIsOpen: setIsImportModalOpen, tableName, fields, unchangeableFields, hiddenFields, columnTypes, apiEndpoint, onImportSuccess: () => setCurrentPage(1), primaryButtonClass, grayButtonClass }} />
      <ExportCSVModal {...{ isOpen: isExportModalOpen, setIsOpen: setIsExportModalOpen, selectedRows, items, fields, hiddenFields, tableName, primaryButtonClass, grayButtonClass }} />
      <AddColumnModal {...{ isOpen: isAddColumnModalOpen, setIsOpen: setIsAddColumnModalOpen, tableName, apiEndpoint, onAddSuccess: handleColumnSuccess, primaryButtonClass, grayButtonClass }} />
      <EditColumnModal {...{ isOpen: isEditColumnModalOpen, setIsOpen: setIsEditColumnModalOpen, tableName, apiEndpoint, columnName: selectedColumn || "", currentDataType: selectedColumn ? columnTypes[selectedColumn] : "", onEditSuccess: handleColumnSuccess, primaryButtonClass, grayButtonClass }} />
      <DeleteColumnModal {...{ isOpen: isDeleteColumnModalOpen, setIsOpen: setIsDeleteColumnModalOpen, tableName, apiEndpoint, columnName: selectedColumn || "", onDeleteSuccess: handleColumnSuccess, primaryButtonClass, grayButtonClass }} />
      <SchemaModal
        isOpen={isSchemaModalOpen}
        setIsOpen={setIsSchemaModalOpen}
        tableName={tableName}
        fields={fields}
        columnTypes={columnTypes}
        foreignKeys={foreignKeys}
        foreignKeyOptions={foreignKeyOptions}
        modalPosition={modalPosition}
        handleDragStart={handleDragStart}
        primaryButtonClass={primaryButtonClass}
        grayButtonClass={grayButtonClass}
        onSaveEdit={saveEdit} selectedForeignKeyItem={null}      />
      <div className="relative">
        <TableNavbar
          setIsFilterOpen={setIsFilterOpen}
          setIsSortOpen={setIsSortOpen}
          setIsColumnsMenuOpen={setIsColumnsMenuOpen}
          setIsModalOpen={setIsModalOpen}
          setIsImportModalOpen={setIsImportModalOpen}
          setIsExportModalOpen={setIsExportModalOpen}
          setIsAddColumnModalOpen={setIsAddColumnModalOpen}
          setIsSchemaModalOpen={setIsSchemaModalOpen}
          isFilterOpen={isFilterOpen}
          isSortOpen={isSortOpen}
          isColumnsMenuOpen={isColumnsMenuOpen}
          isModalOpen={isModalOpen}
          isImportModalOpen={isImportModalOpen}
          isExportModalOpen={isExportModalOpen}
          isAddColumnModalOpen={isAddColumnModalOpen}
          tableName={tableName}
          isLoading={isLoading}
          grayButtonClass={grayButtonClass}
          primaryButtonClass={primaryButtonClass}
          pageSortingComponent={<PageSorting {...{ tableName, itemsPerPage, setItemsPerPage, totalItems: items.length, currentPage, setCurrentPage }} />}
        />
        <FilterMenu {...{ isFilterOpen, setIsFilterOpen, filterCriteria, setFilterCriteria, fields, applyFilter, clearFilter, primaryButtonClass, grayButtonClass }} />
        <SortMenu {...{ isSortOpen, setIsSortOpen, sortCriteria, setSortCriteria, fields, applySort, clearSort, primaryButtonClass, grayButtonClass }} />
        <ColumnsMenu
            {...{
              isColumnsMenuOpen,
              setIsColumnsMenuOpen,
              fields,
              hiddenFields,
              toggleColumnVisibility: (field: string) => {
                setHiddenFields((prev) =>
                  prev.includes(field)
                    ? prev.filter((f) => f !== field)
                    : [...prev, field]
                );
                localStorage.setItem(
                  `${tableName}_hiddenFields`,
                  JSON.stringify(hiddenFields)
                );
              },
            }}
          />
   <SelectedRowsNavbar {...{ selectedRows, confirmDeleteSelected: () => selectedRows.length && setIsDeleteModalOpen(true), grayButtonClass }} />
        <div className="overflow-x-auto bg-white rounded-md border border-gray-200">
          <table className="min-w-full table-auto border-collapse">
          <TableHeader
            {...{
              fields,
              hiddenFields,
              columnTypes,
              handleColumnDragStart: (e, f) => setDraggedColumn(f),
              handleColumnDragOver: (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
              },
              handleColumnDrop,
              hideColumn: (f: string) => {
                setHiddenFields((prev) => {
                  const newHiddenFields = [...prev, f];
                  localStorage.setItem(
                    `${tableName}_hiddenFields`,
                    JSON.stringify(newHiddenFields)
                  );
                  return newHiddenFields;
                });
              },
              selectedRows,
              items: displayedItems,
              setSelectedRows,
              setIsAddColumnModalOpen,
              setIsEditColumnModalOpen,
              setIsDeleteColumnModalOpen,
              setSelectedColumn,
              columnWidths,
              setColumnWidths,
            }}
          />
            <TableBody
              {...{
                items: displayedItems,
                fields,
                hiddenFields,
                unchangeableFields,
                selectedRows,
                editingCell,
                editValue,
                foreignKeyOptions,
                inputRefs,
                toggleRowSelection: (id) => setSelectedRows(prev => prev.includes(id) ? prev.filter(rowId => rowId !== id) : [...prev, id]),
                startEditing: async (id, field, value) => { setEditingCell({ id, field }); setEditValue(value || ""); if (field.endsWith("_id")) await fetchForeignKeyOptions(field); },
                setEditValue,
                saveEdit,
                cancelEdit: () => { setEditingCell(null); setEditValue(""); },
                setToNull,
                onExpandRow: (item) => { 
                  const expandItem = fields.reduce((acc, f) => {
                    if (!isServerManaged[f]) {
                      acc[f] = item[f]?.toString() || "";
                    }
                    return acc;
                  }, {} as { [key: string]: string });
                  console.log("newItem set for expand:", JSON.stringify(expandItem, null, 2));
                  setSelectedItem(item); 
                  setNewItem(expandItem); 
                  setIsExpandModalOpen(true); 
                },
                setSelectedForeignKeyItem,
                setIsForeignKeyModalOpen,
                columnWidths,
              }}
            />
          </table>
        </div>
        <div className="flex justify-end pl-4 py-4">
          {pageSortingComponent}
        </div>
      </div>
    </div>
  );
}