'use client';

import React, { useState, useEffect } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Link from '@tiptap/extension-link';
import ImageResize from 'tiptap-extension-resize-image';
import OrderedList from '@tiptap/extension-ordered-list';
import Blockquote from '@tiptap/extension-blockquote';
import CodeBlock from '@tiptap/extension-code-block';
import TextAlign from '@tiptap/extension-text-align';
import Placeholder from '@tiptap/extension-placeholder';
import Highlight from '@tiptap/extension-highlight';
import CharacterCount from '@tiptap/extension-character-count';
import Mention from '@tiptap/extension-mention';
import Table from '@tiptap/extension-table';
import TableRow from '@tiptap/extension-table-row';
import TableCell from '@tiptap/extension-table-cell';
import TableHeader from '@tiptap/extension-table-header';
import { mergeAttributes } from '@tiptap/core';
import { Button } from '@/components/ui/button';
import ImageGalleryModal from '@/components/ImageGalleryModal/ImageGalleryModal';
import LinkModal from '@/components/PostPage/LinkModal';
import { Plugin, PluginKey } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';
import { Node } from 'prosemirror-model';
import './PostEditor.css';

// HTML Formatter utility - formats HTML with proper indentation
const formatHTML = (html: string): string => {
  const tab = '  ';
  let result = '';
  let indent = 0;

  // Inline elements that shouldn't trigger indentation changes
  const inlineElements = ['a', 'span', 'strong', 'em', 'b', 'i', 'u', 'code', 'small', 'mark', 'del', 'ins', 'sub', 'sup'];
  
  // Self-closing elements
  const selfClosing = ['br', 'hr', 'img', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'param', 'source', 'track', 'wbr'];

  // Split HTML into tokens
  const tokens = html.match(/<[^>]+>|[^<]+/g) || [];

  tokens.forEach((token, index) => {
    if (token.startsWith('<')) {
      // It's a tag
      const isClosing = token.startsWith('</');
      const isSelfClosing = token.endsWith('/>') || selfClosing.some(tag => 
        new RegExp(`<${tag}[\\s>]`, 'i').test(token)
      );
      const tagMatch = token.match(/<\/?([a-zA-Z0-9]+)/);
      const tagName = tagMatch ? tagMatch[1].toLowerCase() : '';
      const isInline = inlineElements.includes(tagName);

      if (isClosing) {
        // Closing tag
        if (!isInline) {
          indent = Math.max(0, indent - 1);
          result += '\n' + tab.repeat(indent) + token;
        } else {
          result += token;
        }
      } else if (isSelfClosing) {
        // Self-closing tag
        result += '\n' + tab.repeat(indent) + token;
      } else {
        // Opening tag
        if (!isInline) {
          result += '\n' + tab.repeat(indent) + token;
          indent++;
        } else {
          result += token;
        }
      }
    } else {
      // Text content
      const trimmed = token.trim();
      if (trimmed) {
        // Check if previous token was an opening inline tag
        const prevToken = tokens[index - 1];
        const nextToken = tokens[index + 1];
        const prevIsInlineOpening = prevToken && prevToken.startsWith('<') && !prevToken.startsWith('</') &&
          inlineElements.some(tag => new RegExp(`<${tag}[\\s>]`, 'i').test(prevToken));
        const nextIsInlineClosing = nextToken && nextToken.startsWith('</') &&
          inlineElements.some(tag => new RegExp(`</${tag}>`, 'i').test(nextToken));
        
        if (prevIsInlineOpening || nextIsInlineClosing) {
          result += trimmed;
        } else {
          result += trimmed;
        }
      }
    }
  });

  return result.trim();
};

// Define props interface explicitly
interface PostEditorProps {
  onSave: (content: string) => void;
  initialContent?: string;
  onContentChange?: (content: string) => void;
}

// Custom Image extension
const CustomImage = ImageResize.extend({
  name: 'image',
  group: 'block',
  inline: false,
  selectable: true,

  addAttributes() {
    return {
      ...this.parent?.(),
      src: { default: null },
      alt: { default: null },
      title: { default: null },
      align: {
        default: 'left',
        parseHTML: (element) => element.getAttribute('data-align') || 'left',
        renderHTML: (attributes) => ({ 'data-align': attributes.align }),
      },
      width: {
        default: null,
        parseHTML: (element) => element.getAttribute('width') || element.style.width || null,
        renderHTML: (attributes) => ({ width: attributes.width || null }),
      },
      height: {
        default: null,
        parseHTML: (element) => element.getAttribute('height') || element.style.height || null,
        renderHTML: (attributes) => ({ height: attributes.height || null }),
      },
    };
  },

  renderHTML({ HTMLAttributes }) {
    const { align, width, height, ...rest } = HTMLAttributes;
    const imgStyles = [width ? `width: ${width}` : '', height ? `height: ${height}` : '']
      .filter(Boolean)
      .join('; ');
    return [
      'img',
      mergeAttributes(
        {
          class: `image-align-${align} max-w-full h-auto my-2 rounded`,
          style: imgStyles,
          'data-align': align,
        },
        rest
      ),
    ];
  },

  parseHTML() {
    return [
      {
        tag: 'img',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLImageElement)) return false;
          return {
            src: dom.getAttribute('src'),
            alt: dom.getAttribute('alt'),
            title: dom.getAttribute('title'),
            width: dom.getAttribute('width') || dom.style.width || null,
            height: dom.getAttribute('height') || dom.style.height || null,
            align: dom.getAttribute('data-align') || 'left',
          };
        },
      },
      {
        tag: 'div[class="image-wrapper"]',
        getAttrs: (dom) => {
          const img = dom.querySelector('img');
          if (!img) return false;
          return {
            src: img.getAttribute('src'),
            alt: img.getAttribute('alt'),
            title: img.getAttribute('title'),
            width: img.getAttribute('width') || img.style.width || null,
            height: img.getAttribute('height') || dom.style.height || null,
            align: img.getAttribute('data-align') || dom.style.textAlign || 'left',
          };
        },
      },
    ];
  },
});

// Custom Table extension with border attributes and background color
const CustomTable = Table.extend({
  name: 'table',

  addAttributes() {
    return {
      borderStyle: {
        default: 'solid',
        parseHTML: (element) => element.getAttribute('data-border-style') || 'solid',
        renderHTML: (attributes) => ({ 'data-border-style': attributes.borderStyle }),
      },
      borderColor: {
        default: '#e5e7eb',
        parseHTML: (element) => element.getAttribute('data-border-color') || '#e5e7eb',
        renderHTML: (attributes) => ({ 'data-border-color': attributes.borderColor }),
      },
      borderWidth: {
        default: '1px',
        parseHTML: (element) => element.getAttribute('data-border-width') || '1px',
        renderHTML: (attributes) => ({ 'data-border-width': attributes.borderWidth }),
      },
      backgroundColor: {
        default: 'transparent',
        parseHTML: (element) => element.getAttribute('data-background-color') || 'transparent',
        renderHTML: (attributes) => ({ 'data-background-color': attributes.backgroundColor }),
      },
    };
  },

  renderHTML({ HTMLAttributes }) {
    return [
      'div',
      { class: 'table-wrapper' },
      [
        'table',
        mergeAttributes(
          {
            class: 'tiptap-table editing',
            style: `border-collapse: collapse;`,
            'data-border-style': HTMLAttributes['data-border-style'] || 'solid',
            'data-border-color': HTMLAttributes['data-border-color'] || '#e5e7eb',
            'data-border-width': HTMLAttributes['data-border-width'] || '1px',
            'data-background-color': HTMLAttributes['data-background-color'] || 'transparent',
          },
          HTMLAttributes
        ),
        0,
      ],
    ];
  },

  addProseMirrorPlugins() {
    const plugins = this.parent?.() || [];
    return [...plugins, createResizePlugin(), createEditingStylePlugin()];
  },
});

// Helper function to get table attributes (for plugins)
function getTableAttributes(node: Node, pos: number, view: EditorView): Record<string, any> {
  const resolved = view.state.doc.resolve(pos);
  let currentNode = node;
  let currentPos = pos;

  for (let depth = resolved.depth; depth >= 0; depth--) {
    const parent = resolved.node(depth);
    if (parent.type.name === 'table') {
      return parent.attrs;
    }
    currentPos = resolved.before(depth);
    currentNode = resolved.node(depth);
  }

  return {
    borderStyle: 'solid',
    borderWidth: '1px',
    borderColor: '#e5e7eb',
    backgroundColor: 'transparent',
  };
}

// Custom TableCell with centered text
const CustomTableCell = TableCell.extend({
  renderHTML({ HTMLAttributes }) {
    // Use default attributes; dynamic styles applied by createEditingStylePlugin and handleSave
    const border = 'solid 1px #e5e7eb';
    return [
      'td',
      mergeAttributes(HTMLAttributes, {
        class: 'tiptap-table-cell',
        style: `padding: 0.5rem; text-align: center; border: ${border};`,
      }),
      0,
    ];
  },
});

// Custom TableHeader with transparent background and centered text
const CustomTableHeader = TableHeader.extend({
  renderHTML({ HTMLAttributes }) {
    // Use default attributes; dynamic styles applied by createEditingStylePlugin and handleSave
    const border = 'solid 1px #e5e7eb';
    const backgroundColor = 'transparent';
    return [
      'th',
      mergeAttributes(HTMLAttributes, {
        class: 'tiptap-table-header',
        style: `padding: 0.5rem; text-align: center; font-weight: bold; background-color: ${backgroundColor}; border: ${border};`,
      }),
      0,
    ];
  },
});

// Plugin to apply inline border styles during editing
function createEditingStylePlugin() {
  return new Plugin({
    key: new PluginKey('tableEditingStyle'),
    view(editorView: EditorView) {
      return {
        update: () => {
          const tables = editorView.dom.querySelectorAll('.tiptap-table') as NodeListOf<HTMLElement>;
          tables.forEach((table) => {
            table.classList.add('editing');
            const attrs = table.dataset;
            const borderStyle = attrs.borderStyle || 'solid';
            const borderWidth = attrs.borderWidth || '1px';
            const borderColor = attrs.borderColor || '#e5e7eb';
            const border = borderStyle === 'none' ? 'none' : `${borderStyle} ${borderWidth} ${borderColor}`;
            const backgroundColor = attrs.backgroundColor || 'transparent';
            const cells = table.querySelectorAll('.tiptap-table-cell');
            const headers = table.querySelectorAll('.tiptap-table-header');
            cells.forEach((cell) => {
              (cell as HTMLElement).style.border = border;
            });
            headers.forEach((header) => {
              (header as HTMLElement).style.border = border;
              (header as HTMLElement).style.backgroundColor = backgroundColor;
            });
          });
        },
      };
    },
  });
}

// Resize plugin for draggable borders
function createResizePlugin() {
  return new Plugin({
    key: new PluginKey('tableResize'),
    view(editorView: EditorView) {
      return {
        update: () => {
          const tables = editorView.dom.querySelectorAll('.tiptap-table') as NodeListOf<HTMLElement>;
          tables.forEach((table) => {
            table.classList.add('editing');
            addResizeHandles(table, editorView);
          });
        },
        destroy: () => {
          document.querySelectorAll('.resize-handle').forEach((handle) => handle.remove());
        },
      };
    },
  });
}

function addResizeHandles(table: HTMLElement, editorView: EditorView) {
  table.querySelectorAll('.resize-handle').forEach((handle) => handle.remove());

  const rows = table.querySelectorAll('tr') as NodeListOf<HTMLElement>;
  const headerRow = table.querySelector('tr');
  if (headerRow) {
    const cells = headerRow.querySelectorAll('th, td') as NodeListOf<HTMLElement>;
    cells.forEach((cell, index) => {
      const handle = document.createElement('div');
      handle.className = 'resize-handle column-resize';
      handle.style.cssText = `
        position: absolute;
        top: 0;
        right: -4px;
        width: 8px;
        height: 100%;
        cursor: col-resize;
        background: transparent;
        z-index: 10;
      `;
      cell.style.position = 'relative';
      cell.appendChild(handle);

      handle.addEventListener('mousedown', (e: MouseEvent) => {
        e.preventDefault();
        startColumnResize(e, table, index, editorView);
      });
      handle.addEventListener('touchstart', (e: TouchEvent) => {
        e.preventDefault();
        startColumnResize(e, table, index, editorView);
      });
    });
  }

  rows.forEach((row, index) => {
    const handle = document.createElement('div');
    handle.className = 'resize-handle row-resize';
    handle.style.cssText = `
      position: absolute;
      bottom: -4px;
      left: 0;
      width: 100%;
      height: 8px;
      cursor: row-resize;
      background: transparent;
      z-index: 10;
    `;
    row.style.position = 'relative';
    row.appendChild(handle);

    handle.addEventListener('mousedown', (e: MouseEvent) => {
      e.preventDefault();
      startRowResize(e, table, index, editorView);
    });
    handle.addEventListener('touchstart', (e: TouchEvent) => {
      e.preventDefault();
      startRowResize(e, table, index, editorView);
    });
  });
}

function startColumnResize(e: MouseEvent | TouchEvent, table: HTMLElement, colIndex: number, editorView: EditorView) {
  const clientX = 'touches' in e ? e.touches[0].clientX : e.clientX;
  const startX = clientX;
  const cells = Array.from(table.querySelectorAll(`tr > *:nth-child(${colIndex + 1})`)) as HTMLElement[];
  const startWidth = cells[0].getBoundingClientRect().width;

  const onMove = (moveEvent: MouseEvent | TouchEvent) => {
    moveEvent.preventDefault();
    const currentX = 'touches' in moveEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
    const delta = currentX - startX;
    const newWidth = Math.max(50, startWidth + delta);
    cells.forEach((cell) => {
      cell.style.width = `${newWidth}px`;
      cell.style.minWidth = `${newWidth}px`;
    });
  };

  const onEnd = () => {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onEnd);
    document.removeEventListener('touchend', onEnd);
    editorView.focus();
  };

  document.addEventListener('mousemove', onMove);
  document.addEventListener('touchmove', onMove, { passive: false });
  document.addEventListener('mouseup', onEnd);
  document.addEventListener('touchend', onEnd);
}

function startRowResize(e: MouseEvent | TouchEvent, table: HTMLElement, rowIndex: number, editorView: EditorView) {
  const clientY = 'touches' in e ? e.touches[0].clientY : e.clientY;
  const startY = clientY;
  const row = table.querySelectorAll('tr')[rowIndex] as HTMLElement;
  const startHeight = row.getBoundingClientRect().height;

  const onMove = (moveEvent: MouseEvent | TouchEvent) => {
    moveEvent.preventDefault();
    const currentY = 'touches' in moveEvent ? moveEvent.touches[0].clientY : moveEvent.clientY;
    const delta = currentY - startY;
    const newHeight = Math.max(20, startHeight + delta);
    row.style.height = `${newHeight}px`;
    row.style.minHeight = `${newHeight}px`;
  };

  const onEnd = () => {
    document.removeEventListener('mousemove', onMove);
    document.removeEventListener('touchmove', onMove);
    document.removeEventListener('mouseup', onEnd);
    document.removeEventListener('touchend', onEnd);
    editorView.focus();
  };

  document.addEventListener('mousemove', onMove);
  document.addEventListener('touchmove', onMove, { passive: false });
  document.addEventListener('mouseup', onEnd);
  document.addEventListener('touchend', onEnd);
}

const PostEditor: React.FC<PostEditorProps> = ({ onSave, initialContent, onContentChange }) => {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        blockquote: false,
        codeBlock: false,
      }),
      Link.configure({
        openOnClick: false,
        autolink: true,
        HTMLAttributes: {
          class: 'text-sky-700 underline',
          rel: 'noopener noreferrer',
          target: '_blank',
        },
      }),
      CustomImage,
      OrderedList,
      Blockquote,
      CodeBlock,
      TextAlign.configure({
        types: ['heading', 'paragraph', 'image'],
      }),
      Placeholder.configure({
        placeholder: 'Start writing your post here...',
      }),
      Highlight.configure({
        multicolor: false,
        HTMLAttributes: { class: 'bg-yellow-200' },
      }),
      CharacterCount.configure({
        limit: 50000,
      }),
      Mention.configure({
        HTMLAttributes: { class: 'mention' },
        suggestion: {
          items: ({ query }) => {
            const suggestions = ['alice', 'bob', 'charlie', 'david', 'emma'];
            return suggestions
              .filter((item) => item.toLowerCase().startsWith(query.toLowerCase()))
              .slice(0, 5);
          },
          render: () => {
            const state: { component: HTMLDivElement | null; popup: HTMLDivElement | null } = {
              component: null,
              popup: null,
            };

            return {
              onStart: (props) => {
                state.component = document.createElement('div');
                state.component.className = 'mention-suggestions';
                state.component.style.position = 'absolute';
                state.component.style.background = 'white';
                state.component.style.border = '1px solid #ccc';
                state.component.style.padding = '5px';
                state.component.innerHTML = props.items
                  .map(
                    (item) =>
                      `<div class="suggestion-item" style="padding: 5px; cursor: pointer;">@${item}</div>`
                  )
                  .join('');

                state.popup = document.body.appendChild(state.component);
                const rect = props.clientRect?.();
                if (rect && state.popup) {
                  state.popup.style.left = `${rect.left}px`;
                  state.popup.style.top = `${rect.bottom}px`;
                }

                state.component.addEventListener('click', (e) => {
                  const target = e.target as HTMLElement;
                  const item = target.textContent?.slice(1);
                  if (item) {
                    props.command({ id: item });
                  }
                });
              },
              onUpdate: (props) => {
                if (state.component) {
                  state.component.innerHTML = props.items
                    .map(
                      (item) =>
                        `<div class="suggestion-item" style="padding: 5px; cursor: pointer;">@${item}</div>`
                    )
                    .join('');
                }
              },
              onExit: () => {
                if (state.popup) {
                  state.popup.remove();
                  state.popup = null;
                  state.component = null;
                }
              },
            };
          },
        },
      }),
      CustomTable.configure({
        resizable: true,
      }),
      TableRow,
      CustomTableHeader,
      CustomTableCell,
    ],
    content: initialContent || '<p>Start writing your post here...</p>',
    onUpdate: ({ editor }) => {
      if (onContentChange) {
        onContentChange(editor.getHTML());
      }
    },
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-xl m-5 focus:outline-none',
      },
      handleDrop: (view, event, slice, moved) => {
        if (!moved && event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
          const file = event.dataTransfer.files[0];
          if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = (e) => {
              const src = e.target?.result as string;
              const coordinates = view.posAtCoords({ left: event.clientX, top: event.clientY });
              if (coordinates) {
                view.dispatch(
                  view.state.tr.insert(
                    coordinates.pos,
                    view.state.schema.nodes.image.create({
                      src,
                      align: 'left',
                      width: '200px',
                      height: 'auto',
                    })
                  )
                );
              }
            };
            reader.readAsDataURL(file);
            return true;
          }
        }
        return false;
      },
    },
  });

  const [showTableSubmenu, setShowTableSubmenu] = useState(false);
  const [showFloatingToolbar, setShowFloatingToolbar] = useState(false);
  const [isCodeView, setIsCodeView] = useState(false);
  const [htmlContent, setHtmlContent] = useState('');
  const [showImageGallery, setShowImageGallery] = useState(false);
  const [showLinkModal, setShowLinkModal] = useState(false);
  const [currentLinkUrl, setCurrentLinkUrl] = useState('');

  // Keyboard shortcuts
  useEffect(() => {
    if (!editor) return;

    const handleKeyDown = (event: KeyboardEvent) => {
      // Ctrl+S to save
      if ((event.ctrlKey || event.metaKey) && event.key === 's') {
        event.preventDefault();
        handleSave();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [editor]);

  // Track text selection (keeping for future use if needed)
  useEffect(() => {
    if (!editor) {
      return;
    }

    const updateSelection = () => {
      const { from, to, empty } = editor.state.selection;
      // Floating toolbar removed - keeping selection tracking for other features
    };

    editor.on('selectionUpdate', updateSelection);
    return () => {
      editor.off('selectionUpdate', updateSelection);
    };
  }, [editor]);

  // Update editor content when initialContent prop changes
  useEffect(() => {
    if (editor && initialContent !== undefined) {
      const currentContent = editor.getHTML();
      const newContent = initialContent || '<p>Start writing your post here...</p>';
      if (currentContent !== newContent) {
        editor.commands.setContent(newContent);
      }
    }
  }, [editor, initialContent]);

  // Touch scrolling handler for edit mode
  useEffect(() => {
    if (!editor) return;

    const handleTouchStart = (e: TouchEvent) => {
      const wrapper = (e.target as HTMLElement).closest('.table-wrapper') as HTMLElement;
      if (!wrapper) return;

      const startX = e.touches[0].clientX;
      const scrollStart = wrapper.scrollLeft;

      const handleTouchMove = (moveEvent: TouchEvent) => {
        moveEvent.preventDefault();
        moveEvent.stopPropagation();
        const currentX = moveEvent.touches[0].clientX;
        const deltaX = startX - currentX;
        wrapper.scrollLeft = scrollStart + deltaX;
      };

      const handleTouchEnd = () => {
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
      };

      document.addEventListener('touchmove', handleTouchMove, { passive: false });
      document.addEventListener('touchend', handleTouchEnd);
    };

    const editorDom = editor.view.dom;
    editorDom.addEventListener('touchstart', handleTouchStart, { passive: false });

    return () => {
      editorDom.removeEventListener('touchstart', handleTouchStart);
    };
  }, [editor]);

  if (!editor) return null;

  const applyStyle = (tag: string) => {
    switch (tag) {
      case 'h1':
        editor.chain().focus().toggleHeading({ level: 1 }).run();
        break;
      case 'h2':
        editor.chain().focus().toggleHeading({ level: 2 }).run();
        break;
      case 'h3':
        editor.chain().focus().toggleHeading({ level: 3 }).run();
        break;
      case 'h4':
        editor.chain().focus().toggleHeading({ level: 4 }).run();
        break;
      case 'h5':
        editor.chain().focus().toggleHeading({ level: 5 }).run();
        break;
      case 'p':
        editor.chain().focus().setParagraph().run();
        break;
      case 'ul':
        editor.chain().focus().toggleBulletList().run();
        break;
      case 'ol':
        editor.chain().focus().toggleOrderedList().run();
        break;
      case 'blockquote':
        editor.chain().focus().setParagraph().toggleBlockquote().run();
        break;
      case 'codeBlock':
        editor.chain().focus().setParagraph().toggleCodeBlock().run();
        break;
      case 'bold':
        editor.chain().focus().toggleBold().run();
        break;
      case 'italic':
        editor.chain().focus().toggleItalic().run();
        break;
      case 'table':
        editor.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: true }).run();
        break;
      case 'addRowAfter':
        editor.chain().focus().addRowAfter().run();
        break;
      case 'addColumnAfter':
        editor.chain().focus().addColumnAfter().run();
        break;
      case 'deleteRow':
        editor.chain().focus().deleteRow().run();
        break;
      case 'deleteColumn':
        editor.chain().focus().deleteColumn().run();
        break;
      case 'mergeCells':
        editor.chain().focus().mergeCells().run();
        break;
      case 'splitCell':
        editor.chain().focus().splitCell().run();
        break;
      case 'deleteTable':
        editor.chain().focus().deleteTable().run();
        break;
      case 'borderNone':
        editor.chain().focus().updateAttributes('table', { borderStyle: 'none' }).run();
        break;
      case 'borderSolid':
        editor.chain().focus().updateAttributes('table', { borderStyle: 'solid', borderWidth: '1px' }).run();
        break;
      case 'borderDashed':
        editor.chain().focus().updateAttributes('table', { borderStyle: 'dashed', borderWidth: '1px' }).run();
        break;
      case 'borderBold':
        editor.chain().focus().updateAttributes('table', { borderStyle: 'special', borderWidth: '3px' }).run();
        break;
      case 'borderColor':
        const borderColor = window.prompt('Enter border color (hex or Tailwind class)', '#e5e7eb');
        if (borderColor) {
          const { state, dispatch } = editor.view;
          const { tr } = state;
          let tableFound = false;
          state.doc.descendants((node, pos) => {
            if (node.type.name === 'table') {
              tableFound = true;
              tr.setNodeMarkup(pos, undefined, {
                ...node.attrs,
                borderColor,
                borderStyle: node.attrs.borderStyle === 'none' ? 'solid' : node.attrs.borderStyle,
              });
              const tableNode = editor.view.dom.querySelector(`.tiptap-table[data-border-color="${node.attrs.borderColor}"]`) as HTMLElement | null;
              if (tableNode) {
                const cells = tableNode.querySelectorAll('.tiptap-table-cell, .tiptap-table-header');
                cells.forEach((cell) => {
                  (cell as HTMLElement).style.borderColor = borderColor;
                });
              }
            }
          });
          if (tableFound) {
            dispatch(tr);
            console.log('Applied borderColor:', borderColor);
          } else {
            console.warn('No table found to apply borderColor');
          }
        }
        break;
      case 'headerBackground':
        const backgroundColor = window.prompt('Enter header background color (hex or Tailwind class)', 'transparent');
        if (backgroundColor) {
          const { state, dispatch } = editor.view;
          const { tr } = state;
          let tableFound = false;
          state.doc.descendants((node, pos) => {
            if (node.type.name === 'table') {
              tableFound = true;
              tr.setNodeMarkup(pos, undefined, {
                ...node.attrs,
                backgroundColor,
              });
              const tableNode = editor.view.dom.querySelector(`.tiptap-table[data-background-color="${node.attrs.backgroundColor}"]`) as HTMLElement | null;
              if (tableNode) {
                const headers = tableNode.querySelectorAll('.tiptap-table-header');
                headers.forEach((header) => {
                  (header as HTMLElement).style.backgroundColor = backgroundColor;
                });
              }
            }
          });
          if (tableFound) {
            dispatch(tr);
            console.log('Applied backgroundColor:', backgroundColor);
          } else {
            console.warn('No table found to apply backgroundColor');
          }
        }
        break;
      default:
        break;
    }
  };

  const setLink = () => {
    // Check if there's already a link at cursor position
    const previousUrl = editor.getAttributes('link').href;
    setCurrentLinkUrl(previousUrl || '');
    setShowLinkModal(true);
  };

  const handleLinkSave = (url: string) => {
    if (url) {
      editor.chain().focus().toggleLink({ href: url, target: '_blank' }).run();
    }
  };

  const handleUnlink = () => {
    editor.chain().focus().unsetLink().run();
  };

  const addImage = () => {
    setShowImageGallery(true);
  };

  const handleImageSelect = (url: string) => {
    if (url) {
      // Insert image with default settings
      editor.chain().focus().insertContent({
        type: 'image',
        attrs: {
          src: url,
          align: 'left',
          width: '400px',
          height: 'auto',
          alt: '',
        },
      }).run();
      
      console.log('Image inserted:', url);
    }
  };

  const setImageAlignment = (align: 'left' | 'center' | 'right') => {
    const { state, view } = editor;
    const { selection } = state;
    
    // Try to find the image node
    let imagePos = null;
    let imageNode = null;

    // Check if current node is an image
    const $pos = selection.$anchor;
    for (let d = $pos.depth; d >= 0; d--) {
      const node = $pos.node(d);
      if (node.type.name === 'image') {
        imageNode = node;
        imagePos = $pos.before(d);
        break;
      }
    }

    // If no image found at current position, check selected node
    if (!imageNode) {
      state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
        if (node.type.name === 'image') {
          imageNode = node;
          imagePos = pos;
          return false;
        }
      });
    }

    if (imageNode && imagePos !== null) {
      const transaction = state.tr.setNodeMarkup(imagePos, undefined, {
        ...imageNode.attrs,
        align,
      });
      view.dispatch(transaction);
      console.log('Image alignment updated to:', align);
    } else {
      console.log('No image selected');
    }
  };

  const setImageSize = (width: string) => {
    const { state, view } = editor;
    const { selection } = state;
    
    // Try to find the image node
    let imagePos = null;
    let imageNode = null;

    // Check if current node is an image
    const $pos = selection.$anchor;
    for (let d = $pos.depth; d >= 0; d--) {
      const node = $pos.node(d);
      if (node.type.name === 'image') {
        imageNode = node;
        imagePos = $pos.before(d);
        break;
      }
    }

    // If no image found at current position, check selected node
    if (!imageNode) {
      state.doc.nodesBetween(selection.from, selection.to, (node, pos) => {
        if (node.type.name === 'image') {
          imageNode = node;
          imagePos = pos;
          return false;
        }
      });
    }

    if (imageNode && imagePos !== null) {
      const transaction = state.tr.setNodeMarkup(imagePos, undefined, {
        ...imageNode.attrs,
        width,
        height: 'auto',
      });
      view.dispatch(transaction);
      console.log('Image size updated to:', width);
    } else {
      console.log('No image selected');
    }
  };

  const toggleHighlight = () => {
    editor.chain().focus().toggleHighlight().run();
  };

  const toggleCodeView = () => {
    if (isCodeView) {
      // Switching from code to visual
      try {
        editor.commands.setContent(htmlContent);
        if (onContentChange) {
          onContentChange(htmlContent);
        }
      } catch (error) {
        console.error('Error parsing HTML:', error);
        // Could show an error message to user here
      }
    } else {
      // Switching from visual to code
      setHtmlContent(editor.getHTML());
    }
    setIsCodeView(!isCodeView);
  };

  const handleSave = () => {
    let contentToSave;
    
    if (isCodeView) {
      contentToSave = htmlContent;
      // Update the editor with the HTML content before saving
      try {
        editor.commands.setContent(htmlContent);
      } catch (error) {
        console.error('Error parsing HTML:', error);
      }
    } else {
      const tables = editor.view.dom.querySelectorAll('.tiptap-table') as NodeListOf<HTMLElement>;
      tables.forEach((table) => {
        table.classList.remove('editing');
        const attrs = table.dataset;
        const borderStyle = attrs.borderStyle || 'solid';
        const borderWidth = attrs.borderWidth || '1px';
        const borderColor = attrs.borderColor || '#e5e7eb';
        const border = borderStyle === 'none' ? 'none' : `${borderStyle} ${borderWidth} ${borderColor}`;
        const cells = table.querySelectorAll('.tiptap-table-cell, .tiptap-table-header');
        cells.forEach((cell) => {
          (cell as HTMLElement).style.border = border;
        });
        const headers = table.querySelectorAll('.tiptap-table-header');
        headers.forEach((header) => {
          (header as HTMLElement).style.backgroundColor = attrs.backgroundColor || 'transparent';
        });
      });
      contentToSave = editor.getHTML();
    }
    
    console.log('Before formatting:', contentToSave.substring(0, 200));
    
    // Format HTML with proper indentation
    contentToSave = formatHTML(contentToSave);
    
    console.log('After formatting:', contentToSave.substring(0, 200));
    console.log('Full formatted HTML:', contentToSave);
    
    onSave(contentToSave);
  };

  return (
    <div className="post-editor-container">
      <div className="post-editor text-gray-600">
        {/* Enhanced Toolbar - Single elegant row */}
        <div className="sticky top-0 bg-white border-b border-gray-200 z-40 px-4 py-2 shadow-sm">
          <div className="flex flex-wrap gap-1 items-center">
            {!isCodeView && (
              <>
                {/* Text formatting */}
                <Button
                  size="sm"
                  onClick={() => applyStyle('bold')}
                  variant={editor.isActive('bold') ? 'secondary' : 'outline'}
                  className="font-bold"
                  title="Bold"
                >
                  B
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('italic')}
                  variant={editor.isActive('italic') ? 'secondary' : 'outline'}
                  className="italic"
                  title="Italic"
                >
                  I
                </Button>
                <Button
                  size="sm"
                  onClick={toggleHighlight}
                  variant={editor.isActive('highlight') ? 'secondary' : 'outline'}
                  title="Highlight"
                >
                  ‚ö°
                </Button>
                
                <div className="h-6 w-px bg-gray-300 mx-1"></div>
                
                {/* Headings */}
                <Button
                  size="sm"
                  onClick={() => applyStyle('h1')}
                  variant={editor.isActive('heading', { level: 1 }) ? 'secondary' : 'outline'}
                  title="Heading 1"
                >
                  H1
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('h2')}
                  variant={editor.isActive('heading', { level: 2 }) ? 'secondary' : 'outline'}
                  title="Heading 2"
                >
                  H2
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('h3')}
                  variant={editor.isActive('heading', { level: 3 }) ? 'secondary' : 'outline'}
                  title="Heading 3"
                >
                  H3
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('h4')}
                  variant={editor.isActive('heading', { level: 4 }) ? 'secondary' : 'outline'}
                  title="Heading 4"
                >
                  H4
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('h5')}
                  variant={editor.isActive('heading', { level: 5 }) ? 'secondary' : 'outline'}
                  title="Heading 5"
                >
                  H5
                </Button>
                
                <div className="h-6 w-px bg-gray-300 mx-1"></div>
                
                {/* Lists */}
                <Button
                  size="sm"
                  onClick={() => applyStyle('ul')}
                  variant={editor.isActive('bulletList') ? 'secondary' : 'outline'}
                  title="Bullet List"
                >
                  ‚Ä¢
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('ol')}
                  variant={editor.isActive('orderedList') ? 'secondary' : 'outline'}
                  title="Numbered List"
                >
                  1.
                </Button>
                
                <div className="h-6 w-px bg-gray-300 mx-1"></div>
                
                {/* Special formatting */}
                <Button
                  size="sm"
                  onClick={() => applyStyle('blockquote')}
                  variant={editor.isActive('blockquote') ? 'secondary' : 'outline'}
                  title="Quote"
                >
                  "
                </Button>
                <Button
                  size="sm"
                  onClick={() => applyStyle('codeBlock')}
                  variant={editor.isActive('codeBlock') ? 'secondary' : 'outline'}
                  title="Code Block"
                >
                  &lt;/&gt;
                </Button>
                
                <div className="h-6 w-px bg-gray-300 mx-1"></div>
                
                {/* Insert elements */}
                <Button size="sm" onClick={setLink} variant="outline" title="Add Link">
                  ÔøΩ
                </Button>
                <Button size="sm" onClick={addImage} variant="outline" title="Add Image">
                  üñºÔ∏è
                </Button>
                <Button
                  size="sm"
                  onClick={() => setShowTableSubmenu(!showTableSubmenu)}
                  variant={showTableSubmenu ? 'secondary' : 'outline'}
                  title="Table"
                >
                  ‚äû
                </Button>
              </>
            )}

            {/* View Toggle */}
            <Button
              size="sm"
              onClick={toggleCodeView}
              variant={isCodeView ? 'secondary' : 'outline'}
              title={isCodeView ? 'Switch to Visual Editor' : 'View HTML Source'}
              className="font-mono ml-auto"
            >
              {isCodeView ? 'üëÅÔ∏è' : '</>'}
            </Button>
          </div>
        </div>

        {/* Table submenu */}
        {showTableSubmenu && !isCodeView && (
          <div className="border-b border-gray-200 bg-gray-50 p-3">
            <div className="flex flex-wrap gap-1">
              <Button
                size="sm"
                onClick={() => applyStyle('table')}
                variant="primary"
              >
                Insert Table
              </Button>
              {editor.isActive('table') && (
                <>
                  <div className="w-px bg-gray-300 mx-2"></div>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('addRowAfter')}
                    variant="outline"
                  >
                    + Row
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('addColumnAfter')}
                    variant="outline"
                  >
                    + Column
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('deleteRow')}
                    variant="outline"
                  >
                    - Row
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('deleteColumn')}
                    variant="outline"
                  >
                    - Column
                  </Button>
                  <div className="w-px bg-gray-300 mx-2"></div>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('mergeCells')}
                    variant="outline"
                  >
                    Merge
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('splitCell')}
                    variant="outline"
                  >
                    Split
                  </Button>
                  <Button
                    size="sm"
                    onClick={() => applyStyle('deleteTable')}
                    variant="outline"
                  >
                    Delete Table
                  </Button>
                </>
              )}
            </div>
          </div>
        )}

        {/* Floating Toolbar */}
                {/* Image Gallery Modal */}
        <ImageGalleryModal
          isOpen={showImageGallery}
          onClose={() => setShowImageGallery(false)}
          onSelectImage={handleImageSelect}
        />

        {/* Link Modal */}
        <LinkModal
          isOpen={showLinkModal}
          onClose={() => setShowLinkModal(false)}
          onSave={handleLinkSave}
          onUnlink={handleUnlink}
          initialUrl={currentLinkUrl}
          hasExistingLink={!!currentLinkUrl}
        />

        {/* Editor Content */}
        <div className="relative">
          {isCodeView ? (
            <div className="p-6">
              <textarea
                value={htmlContent}
                onChange={(e) => {
                  setHtmlContent(e.target.value);
                  if (onContentChange) {
                    onContentChange(e.target.value);
                  }
                }}
                className="w-full min-h-[500px] font-mono text-sm border border-gray-200 rounded-md p-4 focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none"
                style={{
                  backgroundColor: '#1e1e1e',
                  color: '#d4d4d4',
                  fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
                  lineHeight: '1.6',
                  tabSize: 2
                }}
                placeholder="Enter HTML content..."
              />
              <div className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                üí° <strong>Tip:</strong> You can edit the HTML directly here. Switch back to visual mode to see the rendered result.
              </div>
            </div>
          ) : (
            <EditorContent
              editor={editor}
              className="prose prose-lg max-w-none p-6 min-h-[500px] focus:outline-none"
            />
          )}
          
          {/* Character count and status */}
          <div className="flex items-center justify-between px-6 py-3 bg-gray-50 border-t border-gray-200">
            <div className="flex items-center space-x-4 text-sm text-gray-500">
              <span>
                {isCodeView 
                  ? `${htmlContent.length.toLocaleString()} / 50,000 characters (HTML)`
                  : `${editor?.storage.characterCount.characters()?.toLocaleString()} / 50,000 characters`
                }
              </span>
              {!isCodeView && (
                <span>
                  {editor?.storage.characterCount.words()} words
                </span>
              )}
              {isCodeView && (
                <span className="text-blue-600">
                  HTML Source Mode
                </span>
              )}
            </div>
            
            <div className="flex items-center space-x-2">
              <kbd className="px-2 py-1 text-xs bg-gray-200 rounded">Ctrl+S</kbd>
              <span className="text-xs text-gray-500">to save</span>
            </div>
          </div>
        </div>

        {/* Image Gallery Modal */}
        <ImageGalleryModal
          isOpen={showImageGallery}
          onClose={() => setShowImageGallery(false)}
          onSelectImage={handleImageSelect}
        />
      </div>
    </div>
  );
};

export default PostEditor;